<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.25.3"/><link as="script" rel="preload" href="/webpack-runtime-ebb138783c301cd6453a.js"/><link as="script" rel="preload" href="/framework-de237a875aa45b276a9d.js"/><link as="script" rel="preload" href="/app-899e7a83059213f8b071.js"/><link as="script" rel="preload" href="/commons-a30d9b8c89d158d4c38c.js"/><link as="script" rel="preload" href="/component---src-pages-snow-effect-js-4448a114fedbe01b3760.js"/><link as="fetch" rel="preload" href="/page-data\snow_effect\page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data\app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous"/><nav class="navbar navbar-expand navbar-dark bg-dark"><span class="navbar-brand"><img src="/leaf.png" width="42" height="30" class="d-inline-block align-top" alt=""/></span><span class="navbar-brand">Gabe Caldwell</span><div class="mr-auto navbar-nav"><div class="nav-item"><a href="/" data-rb-event-key="/" class="nav-link">Blog</a></div><div class="nav-item"><a href="/resume" data-rb-event-key="/resume" class="nav-link">Resume</a></div><div class="nav-item"><a href="/projects" data-rb-event-key="/projects" class="nav-link">Projects</a></div></div></nav><div class="container-fluid"><br/><div style="max-width:1200px" class="card"><div class="card-header">5/22/2021</div><div class="card-body"><div class="card-title h5"><h2>Creating a Snow Post Process Effect</h2></div><br/><div class="card-title h5">Introduction</div>This blog will be dedicated to breaking down the technical details of the snowy weather post-process effect in my upcoming puzzle game. I implemented this within my custom engine, but it could be done in any engine that supports custom shaders and post processing.<br/><br/>In my post processing system the scene is first rendered into a texture, which is then rendered onto a quad that spans the entire screen. Rendering is done using a custom fragment shader that generates the snow particles in real-time.<br/><br/><i>For more information on how you might implement post processing in OpenGL, I recommend this article: <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">LearnOpenGL - Framebuffers.</a></i><br/><br/><i><b>Note</b>: You can view the source for any of the Shadertoys throughout this article by clicking their title!</i><br/><br/><div class="card-title h5">The Brute Force Approach</div>The brute-force approach to this effect is to calculate the location of each snow particle during every instantiation of the shader. After we have these locations we can determine if a given pixel is within a particle by calculating the distance from the pixel to the particle’s center. If the distance is less than or equal to the particle’s radius we know to draw the particle at this pixel. In order to simplify the rest of this blog, we’ll call the process of comparing a pixel’s distance to the particle’s radius as the pixel “visiting” said particle.<br/><br/>One benefit of this method is we can move our particles freely without any issues. If we pass in a random texture (or use a random function), we can randomize the start location, size, and speed of each particle too. This allows us to create a very dynamic effect that feels very close to actual snow. To prevent particles from moving off-screen, we can use the modulo operator to loop them around the other side.<br/><br/>Here’s a Shadertoy example I made (click the title for source):<br/><div class="card-title h5"><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/NlsGRH?gui=true&amp;t=10&amp;paused=true&amp;muted=false"></iframe></div><br/><div class="card-title h5">Bounding with Joy</div>Unfortunately, the algorithm mentioned above suffers from performance issues when a large number of particles are present. Each pixel in our render target has to visit n particles every frame, resulting in a runtime complexity of O(n).<br/><br/>What if we had a way to limit the number of particles each pixel had to visit? Notice that if we know the bounds of each particle a given pixel only has to visit the particles it’s within the bounds of. In order to accomplish this we can split the texture into an array of tiles. We’ll use these tiles to define the bounds of each particle. To split the texture into tiles we can increase the UV range from [0, 1] to [0, TILES], where TILES is the number of tiles we desire along the Y axis. This can be done by multiplying UV by TILES.<br/><br/>We can then floor the scaled up UV to create a unique ID that represents the entire tile. Lastly, we’ll add 0.5 to the ID’s X and Y component, which centers the ID in the middle of the tile:<br/><p class="card-text" style="font-family:monospace;color:white;background:#333333;padding:10px">#define TILES 10.0 <br/>... <br/>fragColor = vec4(0); <br/>vec2 uv = fragCoord.xy / iResolution.y; <br/>vec2 id = floor(uv * TILES); <br/>id += vec2(0.5);</p><br/>Next, we can use the calculated ID to determine where the particle is located. This is as simple as dividing our ID by the number of tiles. We’ll also define the radius of our particle:<br/><p class="card-text" style="font-family:monospace;color:white;background:#333333;padding:10px">float rad = 0.02; <br/>vec2 pos = id / TILES;</p><br/>Now that we have the radius and position, we can determine if the given pixel should render the particle:<br/><p class="card-text" style="font-family:monospace;color:white;background:#333333;padding:10px">float dist = length(uv - pos);<br/>if(dist &lt;= rad) {<br/>    <!-- -->float v = smoothstep(0.0, 1.0, (rad - dist) / rad);<br/>    <!-- -->fragColor = mix(fragColor, vec4(1), v);<br/>}</p><br/>You should have a screen full of dots now… yay! Let’s add a little more action by moving the “uv” value based on the time. We’ll need to do this before calculating our ID:<br/><p class="card-text" style="tab-size:5em;font-family:monospace;color:white;background:#333333;padding:10px">...<br/>uv -= vec2(iTime, -iTime)*0.2; <br/>vec2 id = floor(uv * TILES); <br/>... <br/></p><br/>Here’s the final result: <br/><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/slsGz8?gui=true&amp;t=10&amp;paused=true&amp;muted=false"></iframe><br/><br/>This is great and all (if what you’re after is a couple moving dots) but it doesn’t look anything like snow. The dots need more diversity in their location and size (we’ll talk about speed later). We can accomplish two of these with a 2D random function. It’s common to see random functions utilize an unpredictable sine wave as their base. You can find many variations of these on Shadertoy, but the one I chose was from here: <a href="https://www.shadertoy.com/view/WstGDj">https://www.shadertoy.com/view/WstGDj</a><br/><p class="card-text" style="font-family:monospace;color:white;background:#333333;padding:10px">float random (vec2 uv) {<br/>    <!-- -->return fract(sin(dot(uv, vec2(135., 263.))) * 103.214532);<br/>}</p>We’ll then call this function to offset the location of our particles. Note, we use modulo to prevent our random offset from being too large:<br/><p class="card-text" style="font-family:monospace;color:white;background:#333333;padding:10px">... <br/>float rad = 0.02 * mod(random(pos), 1.0); <br/>pos.x += mod(random(pos), 2.0 / TILES); <br/>pos.y += mod(random(pos+vec2(4,3)), 2.0 / TILES); <br/>... <br/></p><br/>If you compile now you’ll notice artifacts at the edge of each tile. This is because pixels only check for one particle, the particle created at the center of the tile. As a result, any particles that get offset into a different tile get clipped. Consequently, the solution to this is to also visit the neighboring particles. We do this by repeating the previous “visit” calculation using the IDs of neighboring tiles:<br/><br/><p class="card-text" style="font-family:monospace;color:white;background:#333333;padding:10px">for(int x=-2; x&lt;=0; x++) {<br/>    <!-- -->for(int y=-2; y&lt;=0; y++) {<br/>        <!-- -->float rad = 0.02;<br/>        <!-- -->vec2 id = curid + vec2(x,y);<br/>        <!-- -->vec2 pos = id / TILES;<br/><br/>        <!-- -->pos.x += mod(random(pos), 0.2);<br/>        <!-- -->pos.y += mod(random(pos+vec2(4,3)), 0.2);<br/><br/>        <!-- -->rad *= mod(random(pos), 1.0);<br/>        <!-- -->float dist = length(uv - pos);<br/><br/>        <!-- -->if(dist &lt;= rad) {<br/>            <!-- -->float v = smoothstep(0.0, 1.0, (rad - dist) / rad);<br/>            <!-- -->fragColor = mix(fragColor, vec4(1), v);<br/>        <!-- -->}<br/>    <!-- -->}<br/>}</p><br/>We can create depth in the effect by layering multiple of these on top of one another - increasing speed and radius as the layers get closer. If we move our snow generation code into a separate function we can simply call it 3 times and composite the results. Many other additions can be integrated to make this effect more dynamic and interesting. My Shadertoy implementation (with extras included) can be found below! I encourage you to play around with the parameters and discover what looks best.<br/><br/><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/ftsGzH?gui=true&amp;t=10&amp;paused=true&amp;muted=false"></iframe></div></div></div><br/></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/snow_effect/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-5550bf809f8122e93be5.js"],"app":["/app-899e7a83059213f8b071.js"],"component---src-pages-cel-shade-js":["/component---src-pages-cel-shade-js-bdede01605914410103c.js"],"component---src-pages-index-js":["/component---src-pages-index-js-356a87b349e8433f4971.js"],"component---src-pages-projects-js":["/component---src-pages-projects-js-e63914e2d36e924b6f36.js"],"component---src-pages-resume-js":["/component---src-pages-resume-js-6f8125bdae3915ca59e6.js"],"component---src-pages-snow-effect-js":["/component---src-pages-snow-effect-js-4448a114fedbe01b3760.js"],"component---src-pages-ultrastack-js":["/component---src-pages-ultrastack-js-d50641560fd3e976a810.js"]};/*]]>*/</script><script src="/polyfill-5550bf809f8122e93be5.js" nomodule=""></script><script src="/component---src-pages-snow-effect-js-4448a114fedbe01b3760.js" async=""></script><script src="/commons-a30d9b8c89d158d4c38c.js" async=""></script><script src="/app-899e7a83059213f8b071.js" async=""></script><script src="/framework-de237a875aa45b276a9d.js" async=""></script><script src="/webpack-runtime-ebb138783c301cd6453a.js" async=""></script></body></html>