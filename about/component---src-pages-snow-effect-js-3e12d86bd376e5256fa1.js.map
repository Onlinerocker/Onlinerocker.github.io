{"version":3,"sources":["webpack:///./src/components/real_navbar.js","webpack:///./node_modules/react-bootstrap/esm/divWithClassName.js","webpack:///./node_modules/react-bootstrap/esm/CardImg.js","webpack:///./node_modules/react-bootstrap/esm/Card.js","webpack:///./src/pages/snow_effect.js"],"names":["RealNavbar","props","items","links","forwardRef","p","ref","createElement","className","CardImg","_ref","bsPrefix","variant","_ref$as","as","Component","prefix","displayName","defaultProps","DivStyledAsH5","divWithClassName","DivStyledAsH6","CardBody","createWithBsPrefix","CardTitle","CardSubtitle","CardLink","CardText","CardHeader","CardFooter","CardImgOverlay","Card","bg","text","border","body","children","cardContext","cardHeaderBsPrefix","CardContext","Provider","value","Img","Title","Subtitle","Body","Link","Text","Header","Footer","ImgOverlay","SnowEffect","rel","href","integrity","crossorigin","fluid","style","maxWidth","width","height","frameborder","src","allowfullscreen","fontFamily","color","background","padding","tabSize"],"mappings":"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","file":"component---src-pages-snow-effect-js-3e12d86bd376e5256fa1.js","sourcesContent":["import React from \"react\"\r\nimport Navbar from \"../components/navbar\"\r\n\r\nexport default function RealNavbar(props){\r\n    return (    \r\n        <Navbar items={['Projects', 'Resume', 'Blog', 'About']} links={['/', '/resume', '/blog', '/about']} />\r\n    )\r\n}","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport classNames from 'classnames';\nexport default (function (className) {\n  return React.forwardRef(function (p, ref) {\n    return /*#__PURE__*/React.createElement(\"div\", _extends({}, p, {\n      ref: ref,\n      className: classNames(p.className, className)\n    }));\n  });\n});","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport classNames from 'classnames';\nimport React from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nvar defaultProps = {\n  variant: null\n};\nvar CardImg = React.forwardRef( // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\nfunction (_ref, ref) {\n  var bsPrefix = _ref.bsPrefix,\n      className = _ref.className,\n      variant = _ref.variant,\n      _ref$as = _ref.as,\n      Component = _ref$as === void 0 ? 'img' : _ref$as,\n      props = _objectWithoutPropertiesLoose(_ref, [\"bsPrefix\", \"className\", \"variant\", \"as\"]);\n\n  var prefix = useBootstrapPrefix(bsPrefix, 'card-img');\n  return /*#__PURE__*/React.createElement(Component, _extends({\n    ref: ref,\n    className: classNames(variant ? prefix + \"-\" + variant : prefix, className)\n  }, props));\n});\nCardImg.displayName = 'CardImg';\nCardImg.defaultProps = defaultProps;\nexport default CardImg;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport classNames from 'classnames';\nimport React, { useMemo } from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport createWithBsPrefix from './createWithBsPrefix';\nimport divWithClassName from './divWithClassName';\nimport CardContext from './CardContext';\nimport CardImg from './CardImg';\nvar DivStyledAsH5 = divWithClassName('h5');\nvar DivStyledAsH6 = divWithClassName('h6');\nvar CardBody = createWithBsPrefix('card-body');\nvar CardTitle = createWithBsPrefix('card-title', {\n  Component: DivStyledAsH5\n});\nvar CardSubtitle = createWithBsPrefix('card-subtitle', {\n  Component: DivStyledAsH6\n});\nvar CardLink = createWithBsPrefix('card-link', {\n  Component: 'a'\n});\nvar CardText = createWithBsPrefix('card-text', {\n  Component: 'p'\n});\nvar CardHeader = createWithBsPrefix('card-header');\nvar CardFooter = createWithBsPrefix('card-footer');\nvar CardImgOverlay = createWithBsPrefix('card-img-overlay');\nvar defaultProps = {\n  body: false\n};\nvar Card = React.forwardRef(function (_ref, ref) {\n  var bsPrefix = _ref.bsPrefix,\n      className = _ref.className,\n      bg = _ref.bg,\n      text = _ref.text,\n      border = _ref.border,\n      body = _ref.body,\n      children = _ref.children,\n      _ref$as = _ref.as,\n      Component = _ref$as === void 0 ? 'div' : _ref$as,\n      props = _objectWithoutPropertiesLoose(_ref, [\"bsPrefix\", \"className\", \"bg\", \"text\", \"border\", \"body\", \"children\", \"as\"]);\n\n  var prefix = useBootstrapPrefix(bsPrefix, 'card');\n  var cardContext = useMemo(function () {\n    return {\n      cardHeaderBsPrefix: prefix + \"-header\"\n    };\n  }, [prefix]);\n  return /*#__PURE__*/React.createElement(CardContext.Provider, {\n    value: cardContext\n  }, /*#__PURE__*/React.createElement(Component, _extends({\n    ref: ref\n  }, props, {\n    className: classNames(className, prefix, bg && \"bg-\" + bg, text && \"text-\" + text, border && \"border-\" + border)\n  }), body ?\n  /*#__PURE__*/\n  // @ts-ignore\n  React.createElement(CardBody, null, children) : children));\n});\nCard.displayName = 'Card';\nCard.defaultProps = defaultProps;\nCard.Img = CardImg;\nCard.Title = CardTitle;\nCard.Subtitle = CardSubtitle;\nCard.Body = CardBody;\nCard.Link = CardLink;\nCard.Text = CardText;\nCard.Header = CardHeader;\nCard.Footer = CardFooter;\nCard.ImgOverlay = CardImgOverlay;\nexport default Card;","import React from \"react\"\r\n\r\nimport Container from 'react-bootstrap/Container'\r\nimport Card from \"react-bootstrap/Card\"\r\nimport RealNavbar from \"../components/real_navbar\"\r\n\r\nexport default function SnowEffect() {\r\n    \r\n    var code =  'float dist = length(uv - pos);'\r\n    var code1 = 'if(dist <= rad) {'\r\n    var code2 = 'float v = smoothstep(0.0, 1.0, (rad - dist) / rad);'\r\n    var code3 = 'fragColor = mix(fragColor, vec4(1), v);'\r\n    var code4 = '}'  \r\n\r\n    var code5 = 'float random (vec2 uv) {'\r\n    var code6 = 'return fract(sin(dot(uv, vec2(135., 263.))) * 103.214532);'\r\n    \r\n    var code7 = 'for(int x=-2; x<=0; x++) {'\r\n    var code8 = 'for(int y=-2; y<=0; y++) {'\r\n    var code9 = 'float rad = 0.02;'           \r\n    var code10 = 'vec2 id = curid + vec2(x,y);'\r\n    var code11 = 'vec2 pos = id / TILES;'      \r\n    var code12 = 'pos.x += mod(random(pos), 0.2);'\r\n    var code13 = 'pos.y += mod(random(pos+vec2(4,3)), 0.2);'\r\n    var code14 = 'rad *= mod(random(pos), 1.0);'      \r\n    var code15 = 'float dist = length(uv - pos);'      \r\n    var code16 = 'if(dist <= rad) {'\r\n    var code17 = 'float v = smoothstep(0.0, 1.0, (rad - dist) / rad);'\r\n    var code18 = 'fragColor = mix(fragColor, vec4(1), v);'\r\n        \r\n\r\n    return (\r\n    <div>\r\n      <link\r\n        rel=\"stylesheet\"\r\n        href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\"\r\n        integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\"\r\n        crossorigin=\"anonymous\"\r\n      />\r\n\r\n        <RealNavbar/>  \r\n        <Container fluid>\r\n        <br/>\r\n        <Card style={{maxWidth: '1200px'}}>\r\n            \r\n            <Card.Header>5/22/2021</Card.Header>    \r\n            <Card.Body>\r\n            <Card.Title><h2>Creating a Snow Post Process Effect</h2></Card.Title>\r\n            <br/>\r\n\r\n            <Card.Title>Introduction</Card.Title>\r\n            This blog will be dedicated to breaking down the technical details of the snowy weather post-process effect in my upcoming puzzle game. \r\n            I implemented this within my custom engine, but it could be done in any engine that supports custom shaders and post processing.\r\n            <br/><br/>\r\n            In my post processing system the scene is first rendered into a texture, which is then rendered onto a quad that spans the entire screen. \r\n            Rendering is done using a custom fragment shader that generates the snow particles in real-time.\r\n            <br/><br/>\r\n            <i>\r\n              For more information on how you might implement post processing in OpenGL, \r\n              I recommend this article: <a href=\"https://learnopengl.com/Advanced-OpenGL/Framebuffers\">LearnOpenGL - Framebuffers.</a>\r\n            </i>\r\n            <br/><br/>\r\n            <i>\r\n              <b>Note</b>: You can view the source for any of the Shadertoys throughout this article by clicking their title!\r\n            </i>\r\n            <br/><br/>\r\n\r\n            <Card.Title>The Brute Force Approach</Card.Title>\r\n            The brute-force approach to this effect is to calculate the location of each snow particle during every instantiation of the shader. \r\n            After we have these locations we can determine if a given pixel is within a particle by calculating the distance from the pixel to the particle’s \r\n            center. If the distance is less than or equal to the particle’s radius we know to draw the particle at this pixel. In order to simplify the rest \r\n            of this blog, we’ll call the process of comparing a pixel’s distance to the particle’s radius as the pixel “visiting” said particle.\r\n            <br/><br/>\r\n            One benefit of this method is we can move our particles freely without any issues. If we pass in a random texture (or use a random function), we can randomize the start location, size, \r\n            and speed of each particle too. This allows us to create a very dynamic effect that feels very close to actual snow. To \r\n            prevent particles from moving off-screen, we can use the modulo operator to loop them around the other side.\r\n            <br/><br/>\r\n            Here’s a Shadertoy example I made (click the title for source):\r\n            <br/>\r\n            <Card.Title><iframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/NlsGRH?gui=true&t=10&paused=true&muted=false\" allowfullscreen></iframe></Card.Title>\r\n            <br/>\r\n\r\n            <Card.Title>Bounding with Joy</Card.Title>\r\n            Unfortunately, the algorithm mentioned above suffers from performance issues when a large number of particles are present. Each pixel in our render \r\n            target has to visit n particles every frame, resulting in a runtime complexity of O(n).\r\n            <br/><br/>\r\n            What if we had a way to limit the number of particles each pixel had to visit? Notice that if we know the bounds of each particle a given pixel only has \r\n            to visit the particles it’s within the bounds of. In order to accomplish this we can split the texture into an array of tiles. We’ll use these tiles to define \r\n            the bounds of each particle. To split the texture into tiles we can increase the UV range from [0, 1] to [0, TILES], where TILES is the number of tiles we desire\r\n            along the Y axis. This can be done by multiplying UV by TILES. \r\n            <br/><br/>\r\n\r\n            We can then \r\n            floor the scaled up UV to create a unique ID that represents the entire tile. Lastly, we’ll add 0.5 to the ID’s X and Y component, which centers the ID in the \r\n            middle of the tile:\r\n            <br/>\r\n            <Card.Text style={{fontFamily: 'monospace', color: 'white', background: '#333333', padding: '10px'}}>\r\n            #define TILES 10.0 <br/>\r\n            ... <br/>\r\n            fragColor = vec4(0); <br/>\r\n            vec2 uv = fragCoord.xy / iResolution.y; <br/>\r\n            vec2 id = floor(uv * TILES); <br/>\r\n            id += vec2(0.5);\r\n            </Card.Text>\r\n            <br/>\r\n\r\n            Next, we can use the calculated ID to determine where the particle is located. This is as simple as dividing our ID by the number of tiles. We’ll also define the \r\n            radius of our particle:\r\n            <br/>\r\n            <Card.Text style={{fontFamily: 'monospace', color: 'white', background: '#333333', padding: '10px'}}>\r\n            float rad = 0.02; <br/>\r\n            vec2 pos = id / TILES;\r\n            </Card.Text>\r\n            <br/>\r\n            \r\n            Now that we have the radius and position, we can determine if the given pixel should render the particle:\r\n            <br/>\r\n            <Card.Text style={{fontFamily: 'monospace', color: 'white', background: '#333333', padding: '10px'}}>\r\n                {code}\r\n                <br/>\r\n                {code1}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;{code2}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;{code3}\r\n                <br/>\r\n                {code4}\r\n            </Card.Text>\r\n            <br/>\r\n            You should have a screen full of dots now… yay! Let’s add a little more action by moving the “uv” value \r\n            based on the time. We’ll need to do this before calculating our ID:\r\n            <br/>\r\n            <Card.Text style={{tabSize: '5em', fontFamily: 'monospace', color: 'white', background: '#333333',  padding: '10px'}}>\r\n            ...<br/>\r\n            uv -= vec2(iTime, -iTime)*0.2; <br/>\r\n            vec2 id = floor(uv * TILES); <br/>\r\n            ... <br/>\r\n            </Card.Text>\r\n            <br/>\r\n            Here’s the final result: <br/>\r\n            <iframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/slsGz8?gui=true&t=10&paused=true&muted=false\" allowfullscreen></iframe>\r\n\r\n            <br/><br/>\r\n            This is great and all (if what you’re after is a couple moving dots) but it doesn’t look anything like snow. The dots need more diversity in their location \r\n            and size (we’ll talk about speed later). We can accomplish two of these with a 2D random function. It’s common to see random functions utilize an unpredictable \r\n            sine wave as their base. You can find many variations of these on Shadertoy, but the one I chose was from here: <a href=\"https://www.shadertoy.com/view/WstGDj\">https://www.shadertoy.com/view/WstGDj</a>\r\n            <br/>\r\n            <Card.Text style={{fontFamily: 'monospace', color: 'white', background: '#333333',  padding: '10px'}}>\r\n                {code5}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;{code6}\r\n                <br/>\r\n                {code4}\r\n            </Card.Text>\r\n\r\n            We’ll then call this function to offset the location of our particles. Note, we use modulo to prevent our random offset from being too large:\r\n            <br/>\r\n            <Card.Text style={{fontFamily: 'monospace', color: 'white', background: '#333333',  padding: '10px'}}>\r\n            ... <br/>\r\n            float rad = 0.02 * mod(random(pos), 1.0); <br/>\r\n            pos.x += mod(random(pos), 2.0 / TILES); <br/>\r\n            pos.y += mod(random(pos+vec2(4,3)), 2.0 / TILES); <br/>\r\n            ... <br/>\r\n            </Card.Text>\r\n            <br/>\r\n            If you compile now you’ll notice artifacts at the edge of each tile. This is because pixels only check for one particle, the particle created at \r\n            the center of the tile. As a result, any particles that get offset into a different tile get clipped. Consequently, the solution to this is to also \r\n            visit the neighboring particles. We do this by repeating the previous “visit” calculation using the IDs of neighboring tiles:\r\n\r\n            <br/><br/>\r\n            <Card.Text style={{fontFamily: 'monospace', color: 'white', background: '#333333',  padding: '10px'}}>\r\n                {code7}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;{code8}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code9}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code10}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code11}\r\n                <br/><br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code12}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code13}\r\n                <br/><br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code14}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code15}\r\n                <br/><br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code16}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code17}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code18}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{code4}\r\n                <br/>\r\n                &nbsp;&nbsp;&nbsp;&nbsp;{code4}\r\n                <br/>\r\n                {code4}\r\n            </Card.Text>\r\n\r\n            <br/>\r\n            We can create depth in the effect by layering multiple of these on top of one another - increasing speed and radius as the layers get closer. \r\n            If we move our snow generation code into a separate function we can simply call it 3 times and composite the results. Many other additions can be \r\n            integrated to make this effect more dynamic and interesting. My Shadertoy implementation (with extras included) can be found below! I encourage you to \r\n            play around with the parameters and discover what looks best.\r\n            <br/><br/>\r\n            <iframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/ftsGzH?gui=true&t=10&paused=true&muted=false\" allowfullscreen></iframe>\r\n            </Card.Body>\r\n\r\n        </Card>\r\n        </Container>\r\n\r\n      <br/>\r\n    </div>\r\n  )\r\n}\r\n"],"sourceRoot":""}