<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.25.3"/><link as="script" rel="preload" href="/webpack-runtime-9ed386a0224f94bdbae9.js"/><link as="script" rel="preload" href="/framework-712d0c71a05a512b21eb.js"/><link as="script" rel="preload" href="/app-c9959bfdc16894310609.js"/><link as="script" rel="preload" href="/commons-a30d9b8c89d158d4c38c.js"/><link as="script" rel="preload" href="/component---src-pages-svo-update-3-js-2d2301d86d0526ca25d3.js"/><link as="fetch" rel="preload" href="/page-data\svo_update3\page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data\app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous"/><nav class="navbar navbar-expand navbar-dark bg-dark"><span class="navbar-brand"><img src="/leaf.png" width="42" height="30" class="d-inline-block align-top" alt=""/></span><span class="navbar-brand">Gabe Caldwell</span><div class="mr-auto navbar-nav"><div class="nav-item"><a href="/" data-rb-event-key="/" class="nav-link">Projects</a></div><div class="nav-item"><a href="/resume" data-rb-event-key="/resume" class="nav-link">Resume</a></div><div class="nav-item"><a href="/blog" data-rb-event-key="/blog" class="nav-link">Blog</a></div><div class="nav-item"><a href="/about" data-rb-event-key="/about" class="nav-link">About</a></div></div></nav><div class="container-fluid"><br/><div style="max-width:1200px" class="card"><div class="card-header" style="background:#EEEEEE">7/6/2022</div><div class="card-body"><div class="card-title h5"><h2>SVO Ray Tracer Update #3</h2></div><a href="https://github.com/Onlinerocker/SVO">Project&#x27;s GitHub Repo</a><br/><br/><div class="card-title h5">Improved Camera Controls</div>In order to more thoroughly debug my traversal algorithm, I needed to improve my camera controls. Three sliders for XYZ coordinates was good enough to get a prototype up and running, but it was becoming increasingly important to view the voxels at a variety of angles. My goal was to program camera controls similar to those found in Unreal Engine’s editor. The mouse would rotate the camera, while WASD would translate you along your forward and right vector.<br/><br/>This was relatively quick to implement since SDL already has functionality to grab the mouse X and Y deltas each frame. All I needed to do was feed these into a function that rotates the forward and right vectors. After that, I could calculate the up vector by taking the cross product of forward and right.<br/><br/>Additionally, I added the forward, up, and right vectors to a constant buffer for my ray tracer to use when calculating the ray direction for a given pixel. The X/Y ray direction is calculated by multiplying the pixel position (normalized to [-1, 1]) by the right and up vectors respectively. The final direction calculation comes out as:<br/><br/><b>float3 direction = normalize(Pixel_X * RIGHT + Pixel_Y * UP + FORWARD)</b><br/><br/><div class="card-title h5">Traversal Algorithm Improvements</div>The new traversal algorithm now traverses along the ray, moving up and down the octree to locate the appropriate leaf node to render. There are four possibilities when traversing along the ray:<br/><br/>⦁ Entering an empty voxel: Move along the ray to the next voxel<br/>⦁ Entering a voxel that is non-empty and non-leaf: Move down the octree to the node’s children<br/>⦁ Entering a voxel that is non-empty and leaf: Done! Render the voxel<br/>⦁ Exiting a voxel: Move up the octree one level of depth. Repeat until we’re no longer exiting the newly calculated voxel depth (i.e. we’re no longer exiting roots)<br/><br/>These are continued in a loop until the ray leaves the root voxel or a leaf node is hit.<br/><br/><i>NVIDIA&#x27;s traversal algorithm visualized (credit: NVIDIA)</i><br/><img src="../svo_traversal.png" style="width:40%;max-width:500px;padding-right:19px" class=""/><br/><br/><br/><div class="card-title h5">Traversal Optimization</div>When I began flying through the SVO I noticed significant frame drops when I was inside the structure. This was because the algorithm was fully traversing down/up the SVO for nodes behind me! Leaf nodes that get rendered are only in front of the camera, so there was no sense in searching for leaf nodes we would never render anyway. To account for this, I added a check that prevents the algorithm from travelling down the octree if the node is completely behind the camera. It will only traverse down if the camera is inside the node or the node is in front of the camera. Effectively, it treats nodes behind the camera as being empty and skips over them. After adding this change the frame rate became much more consistent and I was able to explore the inside of the SVO without frame drops.<br/><br/><div class="card-title h5">Dealing With Constant Buffer Limits</div>In DirectX 11 a constant buffer can only contain 4096 float4 vectors. If you do the math, that’s only 65,536 bytes… far less than I would need to store a 512x512x512 SVO.<br/><br/><i>Rendering using a constant buffer. Purple represents empty space.</i><br/><img src="../cbuffer_voxels.png" style="width:40%;max-width:500px;padding-right:19px" class=""/><br/><br/>A constant buffer clearly wasn’t going to cut it. My first thought was to encode the data in a texture. I began digging into the DX11 documentation to figure out how to do this when I ran into something called a Structured buffer. A Structured buffer is a buffer that holds structured data i.e an array of structs. Unlike a cbuffer it also doesn’t require you to specify a specific size in the shader. Additionally, a StructuredBuffer is required to support at least 2GB of data! This was exactly the tool I needed for the job. I added this new buffer to my pixel shader, set up the DX11 API to upload my data to the buffer, and voila! I was now able to render millions of voxels.<br/><br/>The switch out was extremely easy in the shader code since indexing into the structured buffer was exactly the same as indexing into the cbuffer’s array; I just needed to make sure I gave my structured buffer the same variable name.<br/><br/><i>Rendering using a structured buffer (5 million+ voxels here, 134 million+ volumetrically)</i><br/><img src="../structured_buffer_voxels.png" style="width:40%;max-width:500px;padding-right:19px" class=""/><br/><br/><div class="card-title h5">Demo</div>Here is a demo of me flying through/around the SVO. (The white box is a light which renders overtop the SVO… I already fixed this but you’ll have to excuse it in this video)<br/><br/><iframe width="560" height="315" src="https://www.youtube.com/embed/6iKIxKdRjRQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe><br/><br/><div class="card-title h5">What&#x27;s Next?</div>The ray-tracer is already in a great spot, being able to render millions of voxels per frame, just as I had set out to do at the beginning of this project. However, there are still plenty of additions to be made!<br/><br/>Going forward I plan to write an SVO terrain generation algorithm. I also plan to research the possibility of adding/removing voxels. This is going to require the SVO to be rebuilt in some cases. Thus, I’ll have to find a way to speed up the SVO rebuild.</div></div></div><br/></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/svo_update3/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-a407cf3765e733778079.js"],"app":["/app-c9959bfdc16894310609.js"],"component---src-pages-about-js":["/component---src-pages-about-js-50e00aef196e59bc65b5.js"],"component---src-pages-blog-js":["/component---src-pages-blog-js-4ccdbf66fefa83efac0b.js"],"component---src-pages-cel-shade-js":["/component---src-pages-cel-shade-js-ca85c40fd0dc961a9afb.js"],"component---src-pages-fiea-js":["/component---src-pages-fiea-js-3e5a85163a24ccbb3430.js"],"component---src-pages-index-js":["/component---src-pages-index-js-269cbb643b883cb8dbb3.js"],"component---src-pages-resume-js":["/component---src-pages-resume-js-f550664c429804c235a9.js"],"component---src-pages-snow-effect-js":["/component---src-pages-snow-effect-js-3e12d86bd376e5256fa1.js"],"component---src-pages-svo-update-1-js":["/component---src-pages-svo-update-1-js-6dffdd8aef8b45458b16.js"],"component---src-pages-svo-update-2-js":["/component---src-pages-svo-update-2-js-b4c3a9c587c838ce27bd.js"],"component---src-pages-svo-update-3-js":["/component---src-pages-svo-update-3-js-2d2301d86d0526ca25d3.js"],"component---src-pages-tree-gen-js":["/component---src-pages-tree-gen-js-fdaadf6f53da71c1bc80.js"],"component---src-pages-ultrastack-js":["/component---src-pages-ultrastack-js-0734814ca9b34d217f2b.js"]};/*]]>*/</script><script src="/polyfill-a407cf3765e733778079.js" nomodule=""></script><script src="/component---src-pages-svo-update-3-js-2d2301d86d0526ca25d3.js" async=""></script><script src="/commons-a30d9b8c89d158d4c38c.js" async=""></script><script src="/app-c9959bfdc16894310609.js" async=""></script><script src="/framework-712d0c71a05a512b21eb.js" async=""></script><script src="/webpack-runtime-9ed386a0224f94bdbae9.js" async=""></script></body></html>