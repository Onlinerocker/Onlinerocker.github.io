(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{"/2wD":function(e,t,a){"use strict";a.d(t,"a",(function(){return l}));var r=a("q1tI"),n=a.n(r),o=a("RMg3");function l(e){return n.a.createElement(o.a,{items:["Projects","Resume","Blog","About"],links:["/","/resume","/blog","/about"]})}},"2mvg":function(e,t,a){"use strict";var r=a("wx14"),n=a("zLVn"),o=a("TSYQ"),l=a.n(o),i=a("q1tI"),c=a.n(i),s=a("17x9"),d=a.n(s),u=a("vUet"),m=(d.a.string,d.a.bool,d.a.bool,d.a.bool,d.a.bool,c.a.forwardRef((function(e,t){var a=e.bsPrefix,o=e.className,i=e.fluid,s=e.rounded,d=e.roundedCircle,m=e.thumbnail,h=Object(n.a)(e,["bsPrefix","className","fluid","rounded","roundedCircle","thumbnail"]);a=Object(u.a)(a,"img");var b=l()(i&&a+"-fluid",s&&"rounded",d&&"rounded-circle",m&&a+"-thumbnail");return c.a.createElement("img",Object(r.a)({ref:t},h,{className:l()(o,b)}))})));m.displayName="Image",m.defaultProps={fluid:!1,rounded:!1,roundedCircle:!1,thumbnail:!1},t.a=m},"6xyR":function(e,t,a){"use strict";var r=a("wx14"),n=a("zLVn"),o=a("TSYQ"),l=a.n(o),i=a("q1tI"),c=a.n(i),s=a("vUet"),d=a("YdCC"),u=function(e){return c.a.forwardRef((function(t,a){return c.a.createElement("div",Object(r.a)({},t,{ref:a,className:l()(t.className,e)}))}))},m=a("Wzyw"),h=c.a.forwardRef((function(e,t){var a=e.bsPrefix,o=e.className,i=e.variant,d=e.as,u=void 0===d?"img":d,m=Object(n.a)(e,["bsPrefix","className","variant","as"]),h=Object(s.a)(a,"card-img");return c.a.createElement(u,Object(r.a)({ref:t,className:l()(i?h+"-"+i:h,o)},m))}));h.displayName="CardImg",h.defaultProps={variant:null};var b=h,p=u("h5"),f=u("h6"),g=Object(d.a)("card-body"),w=Object(d.a)("card-title",{Component:p}),y=Object(d.a)("card-subtitle",{Component:f}),v=Object(d.a)("card-link",{Component:"a"}),E=Object(d.a)("card-text",{Component:"p"}),x=Object(d.a)("card-header"),k=Object(d.a)("card-footer"),I=Object(d.a)("card-img-overlay"),O=c.a.forwardRef((function(e,t){var a=e.bsPrefix,o=e.className,d=e.bg,u=e.text,h=e.border,b=e.body,p=e.children,f=e.as,w=void 0===f?"div":f,y=Object(n.a)(e,["bsPrefix","className","bg","text","border","body","children","as"]),v=Object(s.a)(a,"card"),E=Object(i.useMemo)((function(){return{cardHeaderBsPrefix:v+"-header"}}),[v]);return c.a.createElement(m.a.Provider,{value:E},c.a.createElement(w,Object(r.a)({ref:t},y,{className:l()(o,v,d&&"bg-"+d,u&&"text-"+u,h&&"border-"+h)}),b?c.a.createElement(g,null,p):p))}));O.displayName="Card",O.defaultProps={body:!1},O.Img=b,O.Title=w,O.Subtitle=y,O.Body=g,O.Link=v,O.Text=E,O.Header=x,O.Footer=k,O.ImgOverlay=I;t.a=O},g0ED:function(e,t,a){"use strict";a.r(t),a.d(t,"default",(function(){return s}));var r=a("q1tI"),n=a.n(r),o=a("7vrA"),l=a("6xyR"),i=a("/2wD"),c=a("2mvg");function s(){return n.a.createElement("div",null,n.a.createElement("link",{rel:"stylesheet",href:"https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css",integrity:"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk",crossorigin:"anonymous"}),n.a.createElement(i.a,null),n.a.createElement(o.a,{fluid:!0},n.a.createElement("br",null),n.a.createElement(l.a,{style:{maxWidth:"1200px"}},n.a.createElement(l.a.Header,{style:{background:"#EEEEEE"}},"7/9/2022"),n.a.createElement(l.a.Body,null,n.a.createElement(l.a.Title,null,n.a.createElement("h2",null,"SVO Ray Tracer Update #4 - Adding/Removing Voxels, Octree Visualization")),n.a.createElement("a",{href:"https://github.com/Onlinerocker/SVO"},"Project's GitHub Repo"),n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement(l.a.Title,null,"Porting Ray Trace Function To CPU"),"In order to support voxel modification, the program needed a way to determine which block you were looking at. The most obvious way to determine this would be to use the same ray trace function we use to render: shoot a ray in the forward direction of the camera and return which voxel you hit first.",n.a.createElement("br",null),n.a.createElement("br",null),"I decided this would be best done on the CPU. I wasn’t aware of any way to make persistent changes to GPU memory from within a pixel shader, and processing input in a pixel shader seemed silly when that processing would take place for every pixel. This meant I needed to port my ray trace code to the CPU. Taking advantage of the using keyword, I was able to greatly reduce the amount of modifications I needed to make to the code:",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement(l.a.Text,{style:{fontFamily:"monospace",color:"white",background:"#333333",padding:"10px"}},"using float3 = glm::vec3",n.a.createElement("br",null),"using float2 = glm::vec2",n.a.createElement("br",null),"using uint = uint32_t",n.a.createElement("br",null),"etc…",n.a.createElement("br",null)),n.a.createElement("br",null),"Most of the modifications I made when porting my ray trace function and helper functions was replacing the swivels with glm::vec constructions.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement(l.a.Title,null,"Adding/Removing Voxels"),"After porting the ray trace function to the CPU, adding and removing voxels was relatively simple. I just flip the bit corresponding to the given voxel to one or zero respectively. The trickier part is recursing up the octree and marking parents as valid or not. When a parent becomes empty after removal, the containing parent needs to mark its child as invalid (empty). Likewise, when we add a voxel to an empty parent, the containing parent needs to mark its child as valid. This process needs to continue until each node is marked invalid or valid in the path we traveled to the voxel.",n.a.createElement("br",null),n.a.createElement("br",null),"Since my traversal algorithm caches a stack in order to move up and down the octree, I simply return this stack when a leaf node is hit. When a leaf node is modified the stack is then used to update its parent nodes as needed.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/N8Q2mEdpiHo",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),n.a.createElement("br",null),n.a.createElement("i",null,"Demo of adding/removing voxels"),n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement(l.a.Title,null,"Subresource vs. Memory Mapping"),"Before adding the ability to add and remove voxels I was using Map, Unmap, and Memcpy upload the voxel data to the GPU. Map requires you to pass D3D11_MAP_WRITE_DISCARD or D3D11_MAP_WRITE_NO_OVERWRITE as CPUUsageFlags. We need to update the data occasionally so “no overwrite” clearly isn't want we want. Write discard, however, forces you to completely clear and reupload the buffer in its entirety. This was not going to work for my purposes since the voxel data buffer was/is very large; the upload time was too slow to do in less than a frame. What I really needed was the ability to only modify a small portion of the buffer.",n.a.createElement("br",null),n.a.createElement("br",null),"Rather than using map/unmap, UpdateSubresource allows us to use the D3D11_MAP_WRITE as CPUUsageFlags. Changing to this function and CPU usage flag gave me the ability to only update a small portion of the buffer on modification, which was exactly what I needed!",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement(l.a.Title,null,"Octree Visualization"),"For debugging and demonstration purposes I added a debug rendering mode to visualize the octree. It works by checking if the rays intersection point is within some distance of the border. If it is, we return a bright yellow color. If it hits a leaf node, we return the given node’s color. If it hits nothing, we return black.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement(c.a,{src:"../octree_screen.png",style:{width:"50%",maxWidth:"900px",paddingRight:"19px"}})))),n.a.createElement("br",null))}}}]);
//# sourceMappingURL=component---src-pages-svo-update-4-js-acb33032709bbbe4d10c.js.map